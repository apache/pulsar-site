"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[80504],{10458:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"administration-load-distribution","title":"Pulsar load distribution","description":"Load distribution across Pulsar brokers","source":"@site/versioned_docs/version-2.3.0/administration-load-distribution.md","sourceDirName":".","slug":"/administration-load-distribution","permalink":"/docs/2.3.0/administration-load-distribution","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/versioned_docs/version-2.3.0/administration-load-distribution.md","tags":[],"version":"2.3.0","frontMatter":{"id":"administration-load-distribution","title":"Pulsar load distribution","sidebar_label":"Load distribution","original_id":"administration-load-distribution"},"sidebar":"docsSidebar","previous":{"title":"Pulsar statistics","permalink":"/docs/2.3.0/administration-stats"},"next":{"title":"Pulsar proxy","permalink":"/docs/2.3.0/administration-proxy"}}');var t=a(74848),s=a(28453);const r={id:"administration-load-distribution",title:"Pulsar load distribution",sidebar_label:"Load distribution",original_id:"administration-load-distribution"},o=void 0,d={},l=[{value:"Load distribution across Pulsar brokers",id:"load-distribution-across-pulsar-brokers",level:2},{value:"Pulsar load manager architecture",id:"pulsar-load-manager-architecture",level:2},{value:"Dynamic assignment of topics to brokers",id:"dynamic-assignment-of-topics-to-brokers",level:3},{value:"Assignment granularity",id:"assignment-granularity",level:3},{value:"Creating namespaces and bundles",id:"creating-namespaces-and-bundles",level:3},{value:"Unloading topics and bundles",id:"unloading-topics-and-bundles",level:3},{value:"Namespace bundles splitting",id:"namespace-bundles-splitting",level:3},{value:"Automatic load shedding",id:"automatic-load-shedding",level:3},{value:"Broker overload thresholds",id:"broker-overload-thresholds",level:4}];function c(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"load-distribution-across-pulsar-brokers",children:"Load distribution across Pulsar brokers"}),"\n",(0,t.jsx)(n.p,{children:"Pulsar is an horizontally scalable messaging system, so it is a core requirement that the traffic\nin a logical cluster must be spread across all the available Pulsar brokers, as evenly as possible."}),"\n",(0,t.jsx)(n.p,{children:"In most cases, this is true out of the box and one shouldn't worry about it. There are, though,\nmultiple settings and tools to control the traffic distribution and they require a bit of\ncontext to understand how the traffic is managed in Pulsar."}),"\n",(0,t.jsx)(n.h2,{id:"pulsar-load-manager-architecture",children:"Pulsar load manager architecture"}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-assignment-of-topics-to-brokers",children:"Dynamic assignment of topics to brokers"}),"\n",(0,t.jsx)(n.p,{children:"Topics are dynamically assigned to brokers based on the load conditions of all brokers in the\ncluster."}),"\n",(0,t.jsx)(n.p,{children:"When a clients starts using new topics that are not assigned to any broker, it will trigger a\nprocess that, given the load conditions, it will choose the best suited broker to acquire ownership\nof such topic."}),"\n",(0,t.jsx)(n.p,{children:'In case of partitioned topics, different partitions might be assigned to different brokers. We talk\nabout "topic" in this context to mean either a non-partitioned topic or one partition of a topic.'}),"\n",(0,t.jsx)(n.p,{children:'The assignment is "dynamic" because it can change very quickly. For example, if the broker owning\nthe topic crashes, the topic will be reassigned immediately to another broker. Another scenario is\nthat the broker owning the topic becomes overloaded. In this case too, the topic will be\nreassigned to a less loaded broker.'}),"\n",(0,t.jsx)(n.p,{children:"The dynamic assignment is made possible by the stateless nature of brokers. This also ensure that\nwe can quickly expand or shrink the cluster based on usage."}),"\n",(0,t.jsx)(n.h3,{id:"assignment-granularity",children:"Assignment granularity"}),"\n",(0,t.jsx)(n.p,{children:"The assignment of topics/partitions to brokers is not done at the individual level. The reason for\nit is to amortize the amount of information that we need to keep track (eg. which topics are\nassigned to a particular broker, what's the load on topics for a broker and similar)."}),"\n",(0,t.jsxs)(n.p,{children:['Instead of individual topic/partition assignment, each broker takes ownership of a subset of the\ntopics for a namespace. This subset is called a "',(0,t.jsx)(n.em,{children:"bundle"}),"\" and effectively it's a sharding\nmechanism."]}),"\n",(0,t.jsx)(n.p,{children:'The namespace is the "administrative" unit: many config knobs or operations are done at the\nnamespace level.'}),"\n",(0,t.jsx)(n.p,{children:'For assignment, a namespaces is sharded into a list of "bundles", with each bundle comprising\na portion of overall hash range of the namespace.'}),"\n",(0,t.jsx)(n.p,{children:"Topics are assigned to a particular bundle by taking the hash of the topic name and seeing in which\nbundle the hash falls into."}),"\n",(0,t.jsx)(n.p,{children:"Each bundle is independent of the others and thus is independently assigned to different brokers."}),"\n",(0,t.jsx)(n.h3,{id:"creating-namespaces-and-bundles",children:"Creating namespaces and bundles"}),"\n",(0,t.jsxs)(n.p,{children:["When creating a new namespace, it will set to use the default number of bundles. This is set in\n",(0,t.jsx)(n.code,{children:"conf/broker.conf"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# When a namespace is created without specifying the number of bundle, this\n# value will be used as the default\ndefaultNumberOfNamespaceBundles=4\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"One can either change the system default, or override it when creating a new namespace:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"\n$ bin/pulsar-admin namespaces create my-tenant/my-namespace --clusters us-west --bundles 16\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"With this command, we're creating a namespace with 16 initial bundles. Therefore the topics for\nthis namespaces can immediately be spread across up to 16 brokers."}),"\n",(0,t.jsx)(n.p,{children:"In general, if the expected traffic and number of topics is known in advance, it's a good idea to\nstart with a reasonable number of bundles instead of waiting for the system to auto-correct the\ndistribution."}),"\n",(0,t.jsx)(n.p,{children:"On a same note, it is normally beneficial to start with more bundles than number of brokers,\nprimarily because of the hashing nature of the distribution of topics into bundles. For example,\nfor a namespace with 1000 topics, using something like 64 bundles will achieve a good distribution\nof traffic across 16 brokers."}),"\n",(0,t.jsx)(n.h3,{id:"unloading-topics-and-bundles",children:"Unloading topics and bundles"}),"\n",(0,t.jsx)(n.p,{children:'In Pulsar there is an admin operation of "unloading" a topic. Unloading means to close the topics,\nrelease ownership and reassign the topics to a new broker, based on current load.'}),"\n",(0,t.jsx)(n.p,{children:"When unload happens, the client will experience a small latency blip, typically in the order of\ntens of milliseconds, while the topic is reassigned."}),"\n",(0,t.jsx)(n.p,{children:"Unloading is the mechanism used by the load-manager to perform the load shedding, but it can\nalso be triggered manually, for example to correct the assignments and redistribute traffic\neven before having any broker overloaded."}),"\n",(0,t.jsx)(n.p,{children:"Unloading a topic has no effect on the assignment, but it will just close and reopen the\nparticular topic:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"\npulsar-admin topics unload persistent://tenant/namespace/topic\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"To unload all topics for a namespace and trigger reassignments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"\npulsar-admin namespaces unload tenant/namespace\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"namespace-bundles-splitting",children:"Namespace bundles splitting"}),"\n",(0,t.jsx)(n.p,{children:"Since the load for the topics in a bundle might change over time, or could just be hard to predict\nupfront, bundles can be split in 2 by brokers. The new smaller bundles can then be reassigned\nto different brokers."}),"\n",(0,t.jsx)(n.p,{children:"The splitting happens based on some tunable thresholds. Any existing bundle that exceeds any\nof the threshold is a candidate to be split. By default the newly split bundles are also\nimmediately offloaded to other brokers, to facilitate the traffic distribution."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# enable/disable namespace bundle auto split\nloadBalancerAutoBundleSplitEnabled=true\n\n# enable/disable automatic unloading of split bundles\nloadBalancerAutoUnloadSplitBundlesEnabled=true\n\n# maximum topics in a bundle, otherwise bundle split will be triggered\nloadBalancerNamespaceBundleMaxTopics=1000\n\n# maximum sessions (producers + consumers) in a bundle, otherwise bundle split will be triggered\nloadBalancerNamespaceBundleMaxSessions=1000\n\n# maximum msgRate (in + out) in a bundle, otherwise bundle split will be triggered\nloadBalancerNamespaceBundleMaxMsgRate=30000\n\n# maximum bandwidth (in + out) in a bundle, otherwise bundle split will be triggered\nloadBalancerNamespaceBundleMaxBandwidthMbytes=100\n\n# maximum number of bundles in a namespace (for auto-split)\nloadBalancerNamespaceMaximumBundles=128\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"automatic-load-shedding",children:"Automatic load shedding"}),"\n",(0,t.jsx)(n.p,{children:"In Pulsar's load manager there is support for automatic load shedding. This means that whenever\nthe system recognized a particular broker is overloaded, it will force some traffic to be\nreassigned to less loaded brokers."}),"\n",(0,t.jsx)(n.p,{children:'When a broker is identifies as overloaded, it will force to "unload" a subset of the bundles, the\nones with higher traffic, that make up for the overload percentage.'}),"\n",(0,t.jsxs)(n.p,{children:["For example, the default threshold is 85% and if a broker is over quota at 95% CPU usage, then\nit will unload the percent difference plus a 5% margin: ",(0,t.jsx)(n.code,{children:"(95% - 85%) + 5% = 15%"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Given the selection of bundles to offload is based on traffic (as a proxy measure for cpu, network\nand memory), broker will unload bundles for at least 15% of traffic."}),"\n",(0,t.jsx)(n.p,{children:"The automatic load shedding is enabled by default and can be disabled with this setting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# Enable/disable automatic bundle unloading for load-shedding\nloadBalancerSheddingEnabled=true\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"There are additional settings that apply to shedding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# Load shedding interval. Broker periodically checks whether some traffic should be offload from\n# some over-loaded broker to other under-loaded brokers\nloadBalancerSheddingIntervalMinutes=1\n\n# Prevent the same topics to be shed and moved to other brokers more that once within this timeframe\nloadBalancerSheddingGracePeriodMinutes=30\n\n"})}),"\n",(0,t.jsx)(n.h4,{id:"broker-overload-thresholds",children:"Broker overload thresholds"}),"\n",(0,t.jsx)(n.p,{children:"The determinations of when a broker is overloaded is based on threshold of CPU, network and\nmemory usage. Whenever either of those metrics reaches the threshold, it will trigger the shedding\n(if enabled)."}),"\n",(0,t.jsx)(n.p,{children:"By default, overload threshold is set at 85%:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# Usage threshold to determine a broker as over-loaded\nloadBalancerBrokerOverloadedThresholdPercentage=85\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"The usage stats are gathered by Pulsar from the system metrics."}),"\n",(0,t.jsx)(n.p,{children:"In case of network utilization, in some cases the network interface speed reported by Linux is\nnot correct and needs to be manually overridden. This is the case in AWS EC2 instances with 1Gbps\nNIC speed for which the OS report 10Gbps speed."}),"\n",(0,t.jsx)(n.p,{children:"Because of the incorrect max speed, the Pulsar load manager might think the broker has not\nreached the NIC capacity, while in fact it's already using all the bandwidth and the traffic is\nbeing slowed down."}),"\n",(0,t.jsx)(n.p,{children:"There is a setting to correct the max NIC speed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"\n# Override the auto-detection of the network interfaces max speed.\n# This option is useful in some environments (eg: EC2 VMs) where the max speed\n# reported by Linux is not reflecting the real bandwidth available to the broker.\n# Since the network usage is employed by the load manager to decide when a broker\n# is overloaded, it is important to make sure the info is correct or override it\n# with the right value here. The configured value can be a double (eg: 0.8) and that\n# can be used to trigger load-shedding even before hitting on NIC limits.\nloadBalancerOverrideBrokerNicSpeedGbps=\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"When the value is empty, Pulsar will use the value reported by the OS."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var i=a(96540);const t={},s=i.createContext(t);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);