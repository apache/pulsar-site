"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[65133],{46137:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"concepts-topic-compaction","title":"Topic Compaction","description":"Pulsar was built with highly scalable persistent storage of message data as a primary objective. Pulsar topics enable you to persistently store as many unacknowledged messages as you need while preserving message ordering. By default, Pulsar stores all unacknowledged/unprocessed messages produced on a topic. Accumulating many unacknowledged messages on a topic is necessary for many Pulsar use cases but it can also be very time intensive for Pulsar consumers to \\"rewind\\" through the entire log of messages.","source":"@site/docs/concepts-topic-compaction.md","sourceDirName":".","slug":"/concepts-topic-compaction","permalink":"/docs/next/concepts-topic-compaction","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/docs/concepts-topic-compaction.md","tags":[],"version":"current","frontMatter":{"id":"concepts-topic-compaction","title":"Topic Compaction","sidebar_label":"Topic Compaction","descriptions":"Get a comprehensive understanding of concepts, features, and workflow of topic compaction in Apache Pulsar."},"sidebar":"docsSidebar","previous":{"title":"Authentication and Authorization","permalink":"/docs/next/concepts-authentication"},"next":{"title":"Message throttling","permalink":"/docs/next/concepts-throttling"}}');var n=o(74848),c=o(28453);const i={id:"concepts-topic-compaction",title:"Topic Compaction",sidebar_label:"Topic Compaction",descriptions:"Get a comprehensive understanding of concepts, features, and workflow of topic compaction in Apache Pulsar."},a=void 0,r={},l=[{value:"Topic compaction example: the stock ticker",id:"topic-compaction-example-the-stock-ticker",level:4},{value:"How topic compaction works",id:"how-topic-compaction-works",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Pulsar was built with highly scalable ",(0,n.jsx)(t.a,{href:"/docs/next/concepts-architecture-overview#persistent-storage",children:"persistent storage"})," of message data as a primary objective. Pulsar topics enable you to persistently store as many unacknowledged messages as you need while preserving message ordering. By default, Pulsar stores ",(0,n.jsx)(t.em,{children:"all"}),' unacknowledged/unprocessed messages produced on a topic. Accumulating many unacknowledged messages on a topic is necessary for many Pulsar use cases but it can also be very time intensive for Pulsar consumers to "rewind" through the entire log of messages.']}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["For a more practical guide to topic compaction, see the ",(0,n.jsx)(t.a,{href:"/docs/next/cookbooks-compaction",children:"Topic compaction cookbook"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:['For some use cases, consumers don\'t need a complete "image" of the topic log. They may only need a few values to construct a more "shallow" image of the log, perhaps even just the most recent value. For these kinds of use cases, Pulsar offers ',(0,n.jsx)(t.strong,{children:"topic compaction"}),". When you run compaction on a topic, Pulsar goes through a topic's backlog and removes messages that are ",(0,n.jsx)(t.em,{children:"obscured"})," by later messages, i.e. topic compaction goes through the topic on a per-key basis and leaves only the most recent message associated with that key."]}),"\n",(0,n.jsx)(t.p,{children:"Pulsar's topic compaction feature:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:'Allows for faster "rewind" through topic logs'}),"\n",(0,n.jsxs)(t.li,{children:["Applies only to ",(0,n.jsx)(t.a,{href:"/docs/next/concepts-architecture-overview#persistent-storage",children:"persistent topics"})]}),"\n",(0,n.jsxs)(t.li,{children:["Triggered automatically when the backlog reaches a certain size or can be triggered manually via the command line. See the ",(0,n.jsx)(t.a,{href:"/docs/next/cookbooks-compaction",children:"Topic compaction cookbook"})]}),"\n",(0,n.jsxs)(t.li,{children:["Is conceptually and operationally distinct from ",(0,n.jsx)(t.a,{href:"/docs/next/concepts-messaging#message-retention-and-expiry",children:"retention and expiry"}),". Topic compaction ",(0,n.jsx)(t.em,{children:"does"}),", however, respect retention. If retention has removed a message from the message backlog of a topic, the message will also not be readable from the compacted topic ledger."]}),"\n"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.h4,{id:"topic-compaction-example-the-stock-ticker",children:"Topic compaction example: the stock ticker"}),"\n",(0,n.jsxs)(t.p,{children:["An example use case for a compacted Pulsar topic would be a stock ticker topic. On a stock ticker topic, each message bears a timestamped dollar value for stocks for purchase (with the message key holding the stock symbol, e.g. ",(0,n.jsx)(t.code,{children:"AAPL"})," or ",(0,n.jsx)(t.code,{children:"GOOG"}),"). With a stock ticker you may care only about the most recent value(s) of the stock and have no interest in historical data (i.e. you don't need to construct a complete image of the topic's sequence of messages per key). Compaction would be highly beneficial in this case because it would keep consumers from needing to rewind through obscured messages."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"how-topic-compaction-works",children:"How topic compaction works"}),"\n",(0,n.jsxs)(t.p,{children:["When topic compaction is triggered ",(0,n.jsx)(t.a,{href:"/docs/next/cookbooks-compaction",children:"via the CLI"}),", it works in the following steps:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Pulsar will iterate over the entire topic from beginning to end."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"For each key that it encounters the compaction routine will keep a record of the latest occurrence of that key."}),"\n",(0,n.jsxs)(t.ol,{start:"2",children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["After that, the broker will create a new ",(0,n.jsx)(t.a,{href:"/docs/next/concepts-architecture-overview#ledgers",children:"BookKeeper ledger"})," and make a second iteration through each message on the topic. For each message:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"If the key matches the latest occurrence of that key, then the key's data payload, message ID, and metadata will be written to the newly created ledger."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"If the key doesn't match the latest then the message will be skipped and left alone."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["If any given message has an empty payload, it will be skipped and considered deleted (akin to the concept of ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tombstone_(data_store)",children:"tombstones"})," in key-value databases)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"At the end of this second iteration through the topic, the newly created BookKeeper ledger is closed and two things are written to the topic's metadata:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The ID of the BookKeeper ledger"}),"\n",(0,n.jsxs)(t.li,{children:["The message ID of the last compacted message (this is known as the ",(0,n.jsx)(t.strong,{children:"compaction horizon"})," of the topic)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Once this metadata is written compaction is complete."}),"\n",(0,n.jsxs)(t.ol,{start:"4",children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["After the initial compaction operation, the Pulsar ",(0,n.jsx)(t.a,{href:"/docs/next/concepts-architecture-overview#brokers",children:"broker"})," that owns the topic is notified whenever any future changes are made to the compaction horizon and compacted backlog. When such changes occur:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Clients (consumers and readers) that have read compacted enabled will attempt to read messages from a topic and either:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Read from the topic like normal (if the message ID is greater than or equal to the compaction horizon) or"}),"\n",(0,n.jsx)(t.li,{children:"Read beginning at the compaction horizon (if the message ID is lower than the compaction horizon)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>a});var s=o(96540);const n={},c=s.createContext(n);function i(e){const t=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(c.Provider,{value:t},e.children)}}}]);