"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[44841],{12588:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"concepts-clients","title":"Pulsar Clients","description":"Pulsar exposes a client API with language bindings for Java, Go, Python, and C++. The client API optimizes and encapsulates Pulsar\'s client-broker communication protocol and exposes a simple and intuitive API for use by applications.","source":"@site/versioned_docs/version-2.5.1/concepts-clients.md","sourceDirName":".","slug":"/concepts-clients","permalink":"/docs/2.5.1/concepts-clients","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/versioned_docs/version-2.5.1/concepts-clients.md","tags":[],"version":"2.5.1","frontMatter":{"id":"concepts-clients","title":"Pulsar Clients","sidebar_label":"Clients","original_id":"concepts-clients"},"sidebar":"docsSidebar","previous":{"title":"Architecture","permalink":"/docs/2.5.1/concepts-architecture-overview"},"next":{"title":"Geo Replication","permalink":"/docs/2.5.1/concepts-replication"}}');var a=t(74848),i=t(28453);const r={id:"concepts-clients",title:"Pulsar Clients",sidebar_label:"Clients",original_id:"concepts-clients"},o=void 0,c={},l=[{value:"Client setup phase",id:"client-setup-phase",level:2},{value:"Reader interface",id:"reader-interface",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Pulsar exposes a client API with language bindings for ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/client-libraries-java",children:"Java"}),", ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/client-libraries-go",children:"Go"}),", ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/client-libraries-python",children:"Python"}),", and ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/client-libraries-cpp",children:"C++"}),". The client API optimizes and encapsulates Pulsar's client-broker communication protocol and exposes a simple and intuitive API for use by applications."]}),"\n",(0,a.jsx)(n.p,{children:"Under the hood, the current official Pulsar client libraries support transparent reconnection and/or connection failover to brokers, queuing of messages until acknowledged by the broker, and heuristics such as connection retries with backoff."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Custom client libraries"}),"\nIf you'd like to create your own client library, we recommend consulting the documentation on Pulsar's custom ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/developing-binary-protocol",children:"binary protocol"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"client-setup-phase",children:"Client setup phase"}),"\n",(0,a.jsx)(n.p,{children:"Before an application creates a producer/consumer, the Pulsar client library needs to initiate a setup phase including two steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The client attempts to determine the owner of the topic by sending an HTTP lookup request to the broker. The request could reach one of the active brokers which, by looking at the (cached) zookeeper metadata knows who is serving the topic or, in case nobody is serving it, tries to assign it to the least loaded broker."}),"\n",(0,a.jsx)(n.li,{children:"Once the client library has the broker address, it creates a TCP connection (or reuse an existing connection from the pool) and authenticates it. Within this connection, client and broker exchange binary commands from a custom protocol. At this point the client sends a command to create producer/consumer to the broker, which will comply after having validated the authorization policy."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Whenever the TCP connection breaks, the client immediately re-initiates this setup phase and keeps trying with exponential backoff to re-establish the producer or consumer until the operation succeeds."}),"\n",(0,a.jsx)(n.h2,{id:"reader-interface",children:"Reader interface"}),"\n",(0,a.jsxs)(n.p,{children:['In Pulsar, the "standard" ',(0,a.jsx)(n.a,{href:"/docs/2.5.1/concepts-messaging#consumers",children:"consumer interface"})," involves using consumers to listen on ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/reference-terminology#topic",children:"topics"}),", process incoming messages, and finally acknowledge those messages when they are processed. Whenever a new subscription is created, it is initially positioned at the end of the topic (by default), and consumers associated with that subscription begin reading with the first message created afterwards.  Whenever a consumer connects to a topic using a pre-existing subscription, it begins reading from the earliest message un-acked within that subscription. In summary, with the consumer interface, subscription cursors are automatically managed by Pulsar in response to ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/concepts-messaging#acknowledgement",children:"message acknowledgements"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"reader interface"})," for Pulsar enables applications to manually manage cursors. When you use a reader to connect to a topic---rather than a consumer---you need to specify ",(0,a.jsx)(n.em,{children:"which"})," message the reader begins reading from when it connects to a topic. When connecting to a topic, the reader interface enables you to begin with:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.strong,{children:"earliest"})," available message in the topic"]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.strong,{children:"latest"})," available message in the topic"]}),"\n",(0,a.jsx)(n.li,{children:'Some other message between the earliest and the latest. If you select this option, you\'ll need to explicitly provide a message ID. Your application will be responsible for "knowing" this message ID in advance, perhaps fetching it from a persistent data store or cache.'}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'The reader interface is helpful for use cases like using Pulsar to provide effectively-once processing semantics for a stream processing system. For this use case, it\'s essential that the stream processing system be able to "rewind" topics to a specific message and begin reading there. The reader interface provides Pulsar clients with the low-level abstraction necessary to "manually position" themselves within a topic.'}),"\n",(0,a.jsx)(n.p,{children:"Internally, the reader interface is implemented as a consumer using an exclusive, non-durable subscription to the topic with a randomly-allocated name."}),"\n",(0,a.jsxs)(n.p,{children:["[ ",(0,a.jsx)(n.strong,{children:"IMPORTANT"})," ]"]}),"\n",(0,a.jsxs)(n.p,{children:["Unlike subscription/consumer, readers are non-durable in nature and does not prevent data in a topic from being deleted, thus it is ",(0,a.jsx)(n.em,{children:(0,a.jsx)(n.strong,{children:"strongly"})})," advised that ",(0,a.jsx)(n.a,{href:"/docs/2.5.1/cookbooks-retention-expiry",children:"data retention"})," be configured. If data retention for a topic is not configured for an adequate amount of time, messages that the reader has not yet read might be deleted .  This causes the readers to essentially skip messages. Configuring the data retention for a topic guarantees the reader with a certain duration to read a message."]}),"\n",(0,a.jsx)(n.p,{children:'Please also note that a reader can have a "backlog", but the metric is only used for users to know how behind the reader is. The metric is not considered for any backlog quota calculations.'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The Pulsar consumer and reader interfaces",src:t(34968).A+"",width:"1289",height:"1720"})}),"\n",(0,a.jsx)(n.p,{children:"Here's a Java example that begins reading from the earliest available message on a topic:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'\nimport org.apache.pulsar.client.api.Message;\nimport org.apache.pulsar.client.api.MessageId;\nimport org.apache.pulsar.client.api.Reader;\n\n// Create a reader on a topic and for a specific message (and onward)\nReader<byte[]> reader = pulsarClient.newReader()\n    .topic("reader-api-test")\n    .startMessageId(MessageId.earliest)\n    .create();\n\nwhile (true) {\n    Message message = reader.readNext();\n\n    // Process the message\n}\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"To create a reader that reads from the latest available message:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"\nReader<byte[]> reader = pulsarClient.newReader()\n    .topic(topic)\n    .startMessageId(MessageId.latest)\n    .create();\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"To create a reader that reads from some message between the earliest and the latest:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"\nbyte[] msgIdBytes = // Some byte array\nMessageId id = MessageId.fromByteArray(msgIdBytes);\nReader<byte[]> reader = pulsarClient.newReader()\n    .topic(topic)\n    .startMessageId(id)\n    .create();\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},34968:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/pulsar-reader-consumer-interfaces-4c838d3fa1b811f2c074087d44b991ea.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);