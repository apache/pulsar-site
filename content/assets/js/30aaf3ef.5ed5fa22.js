"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[86032],{46555:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});var n=r(9772),t=r(74848),o=r(28453);const a={author:"Xiaolong Ran",authorURL:"https://twitter.com/wolf4j1",title:"Apache Pulsar 2.4.2"},i=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Use classLoaders to load Java functions",id:"use-classloaders-to-load-java-functions",level:2},{value:"Start Broker with Functions worker",id:"start-broker-with-functions-worker",level:2},{value:"Add error code and error message when a key does not exist",id:"add-error-code-and-error-message-when-a-key-does-not-exist",level:2},{value:"Deduplication",id:"deduplication",level:2},{value:"Consume data from the earliest location",id:"consume-data-from-the-earliest-location",level:2},{value:"Close previous dispatcher when the subscription type changes",id:"close-previous-dispatcher-when-the-subscription-type-changes",level:2},{value:"Select an active consumer based on the subscription order",id:"select-an-active-consumer-based-on-the-subscription-order",level:2},{value:"Remove failed stale producer from the connection",id:"remove-failed-stale-producer-from-the-connection",level:2},{value:"Add new APIs for schema",id:"add-new-apis-for-schema",level:2},{value:"Expose <code>getLastMessageId()</code> method in consumerImpl",id:"expose-getlastmessageid-method-in-consumerimpl",level:2},{value:"Add new <code>send()</code> interface in C++/Go",id:"add-new-send-interface-in-cgo",level:2},{value:"Consumer background tasks are cancelled after subscription failures",id:"consumer-background-tasks-are-cancelled-after-subscription-failures",level:2},{value:"Delete topics attached with regex consumers",id:"delete-topics-attached-with-regex-consumers",level:2},{value:"Reference",id:"reference",level:2}];function d(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"We are proud to publish Apache Pulsar 2.4.2. Thank the great efforts from Apache Pulsar community with over 110 commits, covering improvements and bug fixes."}),"\n",(0,t.jsxs)(s.p,{children:["For detailed changes related to 2.4.2 release, refer to ",(0,t.jsx)("b",{children:(0,t.jsx)(s.a,{href:"/release-notes/#2.4.2",children:"release notes"})}),"."]}),"\n",(0,t.jsx)(s.p,{children:"I will highlight some improvements and bug fixes in this blog."}),"\n",(0,t.jsx)(s.h2,{id:"use-classloaders-to-load-java-functions",children:"Use classLoaders to load Java functions"}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, windowed functions can work well whether Java Functions instances use shaded JAR or classLoaders, and functionClassLoader is set correctly when the ",(0,t.jsx)(s.code,{children:"--output-serde-classname"})," option is enabled."]}),"\n",(0,t.jsx)(s.p,{children:"Before Pulsar 2.4.2, Java Functions instances are started with a shaded JAR, and different classLoaders are used to load the internal Pulsar code, user code, and the interfaces that the two interacts with each other. This change results in two issues:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The windowed functions do not work well if Java Functions instances use classLoaders."}),"\n",(0,t.jsxs)(s.li,{children:["When using the ",(0,t.jsx)(s.code,{children:"--output-serde-classname"})," option, functionClassLoader is not set correctly."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"start-broker-with-functions-worker",children:"Start Broker with Functions worker"}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, we can start Broker with Functions worker when broker client is enabled with TLS. Before Pulsar 2.4.2, when we run Functions worker with the broker, it checks whether TLS is enabled in the ",(0,t.jsx)(s.code,{children:"function_worker.yml"})," file. If TLS is enabled, it uses TLS port. However, when TLS is enabled on Functions worker, it checks the ",(0,t.jsx)(s.code,{children:"broker.conf"}),". Since Functions worker runs with the broker, it makes sense to check the ",(0,t.jsx)(s.code,{children:"broker.conf"})," as the single source of truth about whether or not to use TLS."]}),"\n",(0,t.jsx)(s.h2,{id:"add-error-code-and-error-message-when-a-key-does-not-exist",children:"Add error code and error message when a key does not exist"}),"\n",(0,t.jsx)(s.p,{children:"In Pulsar Functions, BookKeeper is supported to store the state of Functions. When users attempt to fetch a key that does not exist from function state, an NPE(NullPointerException) error occurs. In Pulsar 2.4.2, we add error code and error message for the case when a key does not exist."}),"\n",(0,t.jsx)(s.h2,{id:"deduplication",children:"Deduplication"}),"\n",(0,t.jsx)(s.p,{children:'Deduplication removes messages based on the the largest sequence ID that pre-persisted. If an error is persisted to BookKeeper, a retry attempt is "deduplicated" with no message ever getting persisted. In version 2.4.2, we fix the issue from the following two aspects:'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Double check the pending messages and return error to the producer when the duplication status is uncertain. For example, when a message is still pending."}),"\n",(0,t.jsx)(s.li,{children:"Sync back the lastPushed map with the lastStored map after failures."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"consume-data-from-the-earliest-location",children:"Consume data from the earliest location"}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, we add ",(0,t.jsx)(s.code,{children:"--subs-position"})," for Pulsar Sinks, so users can consume data from the latest and earliest locations. Before 2.4.2 release, data in topics is consumed from the latest location in Pulsar Sinks by default, and users can not consume the earliest data in sink topic."]}),"\n",(0,t.jsx)(s.h2,{id:"close-previous-dispatcher-when-the-subscription-type-changes",children:"Close previous dispatcher when the subscription type changes"}),"\n",(0,t.jsx)(s.p,{children:"In Pulsar 2.4.2, when the type of a subscription changes, a new dispatcher is created, and the old dispatcher is closed, thus avoiding memory leaks. Before 2.4.2, when the subscription type of a topic changes, a new dispatcher is created and the old one is discarded, yet not closed, which causes memory leaks. If the cursor is not durable, the subscription is closed and removed from the topic when all consumers are removed. The dispatcher should be closed at this time. Otherwise, RateLimiter instances are not garbage collected, which results in a memory leak."}),"\n",(0,t.jsx)(s.h2,{id:"select-an-active-consumer-based-on-the-subscription-order",children:"Select an active consumer based on the subscription order"}),"\n",(0,t.jsx)(s.p,{children:'In Pulsar 2.4.2, the active consumer is selected based on the subscription order. The first consumer in the consumer list is selected as an active consumer without sorting. Before 2.4.2, the active consumer is selected based on the priority level and consumer name. In this case, the active consumer joins and leaves, and no consumer is actually elected as "active" or consumes messages.'}),"\n",(0,t.jsx)(s.h2,{id:"remove-failed-stale-producer-from-the-connection",children:"Remove failed stale producer from the connection"}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, failed producer is removed correctly from the connection. Before Pulsar 2.4.2, broker cannot clean up the old failed producer correctly from the connection. When broker tries to clean up ",(0,t.jsx)(s.code,{children:"producer-future"})," in the failed producer, it removes the newly created ",(0,t.jsx)(s.code,{children:"producer-future"})," rather than the old failed producer, and the following error occurs in broker."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-text",children:"\n17:22:00.700 [pulsar-io-21-26] WARN  org.apache.pulsar.broker.service.ServerCnx - [/1.1.1.1:1111][453] Producer with id persistent://prop/cluster/ns/topic is already present on the connection\n\n"})}),"\n",(0,t.jsx)(s.h2,{id:"add-new-apis-for-schema",children:"Add new APIs for schema"}),"\n",(0,t.jsx)(s.p,{children:"In Pulsar 2.4.2, we add the following APIs for schema:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"getAllVersions"}),": return the list of schema versions for a given topic."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"testCompatibility"}),": be able to test the compatibility for a schema without registering it."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"getVersionBySchema"}),": provide a schema definition and provide the schema version for it."]}),"\n"]}),"\n",(0,t.jsxs)(s.h2,{id:"expose-getlastmessageid-method-in-consumerimpl",children:["Expose ",(0,t.jsx)(s.code,{children:"getLastMessageId()"})," method in consumerImpl"]}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, we expose ",(0,t.jsx)(s.code,{children:"getLastMessageId()"})," method in consumerImpl. It benefits users when they want to know the lag messages, or only consume messages before the current time."]}),"\n",(0,t.jsxs)(s.h2,{id:"add-new-send-interface-in-cgo",children:["Add new ",(0,t.jsx)(s.code,{children:"send()"})," interface in C++/Go"]}),"\n",(0,t.jsxs)(s.p,{children:["In Pulsar 2.4.2, we add new ",(0,t.jsx)(s.code,{children:"send()"})," interface in C++/Go, so the ",(0,t.jsx)(s.code,{children:"MessageID"})," will be returned to users. The logic is consistent with that in Java. In Java client, the ",(0,t.jsx)(s.code,{children:"MessageId send(byte[] message)"})," returns ",(0,t.jsx)(s.code,{children:"MessageId"})," for users."]}),"\n",(0,t.jsx)(s.h2,{id:"consumer-background-tasks-are-cancelled-after-subscription-failures",children:"Consumer background tasks are cancelled after subscription failures"}),"\n",(0,t.jsx)(s.p,{children:"In Pulsar 2.4.2, we ensure that consumer background tasks are cancelled after subscription failures. Before 2.4.2, some background consumer tasks are started in the ConsumerImpl constructor though these tasks are not cancelled if the consumer creation fails, leaving active references to these objects."}),"\n",(0,t.jsx)(s.h2,{id:"delete-topics-attached-with-regex-consumers",children:"Delete topics attached with regex consumers"}),"\n",(0,t.jsx)(s.p,{children:"In Pulsar 2.4.2, we can delete topics attached with a regex consumer. The followings are detailed methods."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Add a flag in CommandSubscribe so that a regex consumer will never trigger the creation of a topic."}),"\n",(0,t.jsx)(s.li,{children:"Subscribe to a non-existing topic. When a specific error occurs, the consumer is interpreted as a permanent failure and thus stopping retrying."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Before 2.4.2, it's not possible to delete topics when there is a regex consumer attached to them. The reason is that the regex consumer will immediately reconnect and re-create the topic."}),"\n",(0,t.jsx)(s.h2,{id:"reference",children:"Reference"}),"\n",(0,t.jsxs)(s.p,{children:["Download Pulsar 2.4.2 ",(0,t.jsx)(s.a,{href:"https://pulsar.apache.org/download/",children:"here"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"If you have any questions or suggestions, contact us with mailing lists or slack."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"mailto:users@pulsar.apache.org",children:"users@pulsar.apache.org"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"mailto:dev@pulsar.apache.org",children:"dev@pulsar.apache.org"})}),"\n",(0,t.jsxs)(s.li,{children:["Pulsar slack channel: ",(0,t.jsx)(s.a,{href:"https://apache-pulsar.slack.com/",children:"https://apache-pulsar.slack.com/"})]}),"\n",(0,t.jsxs)(s.li,{children:["You can self-register at ",(0,t.jsx)(s.a,{href:"https://apache-pulsar.herokuapp.com/",children:"https://apache-pulsar.herokuapp.com/"})]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Looking forward to your contributions to ",(0,t.jsx)(s.a,{href:"https://github.com/apache/pulsar",children:"Pulsar"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>i});var n=r(96540);const t={},o=n.createContext(t);function a(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(o.Provider,{value:s},e.children)}},9772:e=>{e.exports=JSON.parse('{"permalink":"/blog/2019/12/04/Apache-Pulsar-2-4-2","editUrl":"https://github.com/apache/pulsar-site/edit/main/blog/2019-12-04-Apache-Pulsar-2-4-2.md","source":"@site/blog/2019-12-04-Apache-Pulsar-2-4-2.md","title":"Apache Pulsar 2.4.2","description":"We are proud to publish Apache Pulsar 2.4.2. Thank the great efforts from Apache Pulsar community with over 110 commits, covering improvements and bug fixes.","date":"2019-12-04T00:00:00.000Z","tags":[],"readingTime":5.105,"hasTruncateMarker":true,"authors":[{"name":"Xiaolong Ran","url":"https://twitter.com/wolf4j1","key":null,"page":null}],"frontMatter":{"author":"Xiaolong Ran","authorURL":"https://twitter.com/wolf4j1","title":"Apache Pulsar 2.4.2"},"unlisted":false,"prevItem":{"title":"Pulsar Summit San Francisco 2020 CFP is now open","permalink":"/blog/2019/12/18/Pulsar-summit-cfp"},"nextItem":{"title":"Apache Pulsar 2.4.0","permalink":"/blog/2019/07/05/Apache-Pulsar-2-4-0"}}')}}]);