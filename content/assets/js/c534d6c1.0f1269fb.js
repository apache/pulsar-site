"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[16380],{91488:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"concepts-topic-compaction","title":"Topic Compaction","description":"Pulsar was built with highly scalable persistent storage of message data as a primary objective. Pulsar topics enable you to persistently store as many unacknowledged messages as you need while preserving message ordering. By default, Pulsar stores all unacknowledged/unprocessed messages produced on a topic. Accumulating many unacknowledged messages on a topic is necessary for many Pulsar use cases but it can also be very time intensive for Pulsar consumers to \\"rewind\\" through the entire log of messages.","source":"@site/versioned_docs/version-4.0.x/concepts-topic-compaction.md","sourceDirName":".","slug":"/concepts-topic-compaction","permalink":"/docs/4.0.x/concepts-topic-compaction","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/versioned_docs/version-4.0.x/concepts-topic-compaction.md","tags":[],"version":"4.0.x","frontMatter":{"id":"concepts-topic-compaction","title":"Topic Compaction","sidebar_label":"Topic Compaction","descriptions":"Get a comprehensive understanding of concepts, features, and workflow of topic compaction in Apache Pulsar."},"sidebar":"docsSidebar","previous":{"title":"Authentication and Authorization","permalink":"/docs/4.0.x/concepts-authentication"},"next":{"title":"Message throttling","permalink":"/docs/4.0.x/concepts-throttling"}}');var s=t(74848),i=t(28453);const c={id:"concepts-topic-compaction",title:"Topic Compaction",sidebar_label:"Topic Compaction",descriptions:"Get a comprehensive understanding of concepts, features, and workflow of topic compaction in Apache Pulsar."},a=void 0,r={},l=[{value:"Topic compaction example: the stock ticker",id:"topic-compaction-example-the-stock-ticker",level:4},{value:"How topic compaction works",id:"how-topic-compaction-works",level:2},{value:"Compaction Configuration",id:"compaction-configuration",level:2},{value:"Key Configuration Parameters",id:"key-configuration-parameters",level:3},{value:"Null Key Handling",id:"null-key-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3}];function d(e){const o={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(o.p,{children:["Pulsar was built with highly scalable ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/concepts-architecture-overview#persistent-storage",children:"persistent storage"})," of message data as a primary objective. Pulsar topics enable you to persistently store as many unacknowledged messages as you need while preserving message ordering. By default, Pulsar stores ",(0,s.jsx)(o.em,{children:"all"}),' unacknowledged/unprocessed messages produced on a topic. Accumulating many unacknowledged messages on a topic is necessary for many Pulsar use cases but it can also be very time intensive for Pulsar consumers to "rewind" through the entire log of messages.']}),"\n",(0,s.jsxs)(o.blockquote,{children:["\n",(0,s.jsxs)(o.p,{children:["For a more practical guide to topic compaction, see the ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/cookbooks-compaction",children:"Topic compaction cookbook"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(o.p,{children:['For some use cases, consumers don\'t need a complete "image" of the topic log. They may only need a few values to construct a more "shallow" image of the log, perhaps even just the most recent value. For these kinds of use cases, Pulsar offers ',(0,s.jsx)(o.strong,{children:"topic compaction"}),". When you run compaction on a topic, Pulsar goes through a topic's backlog and removes messages that are ",(0,s.jsx)(o.em,{children:"obscured"})," by later messages, i.e. topic compaction goes through the topic on a per-key basis and leaves only the most recent message associated with that key."]}),"\n",(0,s.jsx)(o.p,{children:"Pulsar's topic compaction feature:"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:'Allows for faster "rewind" through topic logs'}),"\n",(0,s.jsxs)(o.li,{children:["Applies only to ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/concepts-architecture-overview#persistent-storage",children:"persistent topics"})]}),"\n",(0,s.jsxs)(o.li,{children:["Triggered automatically when the backlog reaches a certain size or can be triggered manually via the command line. See the ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/cookbooks-compaction",children:"Topic compaction cookbook"})]}),"\n",(0,s.jsxs)(o.li,{children:["Is conceptually and operationally distinct from ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/concepts-messaging#message-retention-and-expiry",children:"retention and expiry"}),". Topic compaction ",(0,s.jsx)(o.em,{children:"does"}),", however, respect retention. If retention has removed a message from the message backlog of a topic, the message will also not be readable from the compacted topic ledger."]}),"\n"]}),"\n",(0,s.jsxs)(o.blockquote,{children:["\n",(0,s.jsx)(o.h4,{id:"topic-compaction-example-the-stock-ticker",children:"Topic compaction example: the stock ticker"}),"\n",(0,s.jsxs)(o.p,{children:["An example use case for a compacted Pulsar topic would be a stock ticker topic. On a stock ticker topic, each message bears a timestamped dollar value for stocks for purchase (with the message key holding the stock symbol, e.g. ",(0,s.jsx)(o.code,{children:"AAPL"})," or ",(0,s.jsx)(o.code,{children:"GOOG"}),"). With a stock ticker you may care only about the most recent value(s) of the stock and have no interest in historical data (i.e. you don't need to construct a complete image of the topic's sequence of messages per key). Compaction would be highly beneficial in this case because it would keep consumers from needing to rewind through obscured messages."]}),"\n"]}),"\n",(0,s.jsx)(o.h2,{id:"how-topic-compaction-works",children:"How topic compaction works"}),"\n",(0,s.jsxs)(o.p,{children:["When topic compaction is triggered ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/cookbooks-compaction",children:"via the CLI"}),", it works in the following steps:"]}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsx)(o.li,{children:"Pulsar will iterate over the entire topic from beginning to end."}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"For each key that it encounters the compaction routine will keep a record of the latest occurrence of that key."}),"\n",(0,s.jsxs)(o.ol,{start:"2",children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:["After that, the broker will create a new ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/concepts-architecture-overview#ledgers",children:"BookKeeper ledger"})," and make a second iteration through each message on the topic. For each message:"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"If the key matches the latest occurrence of that key, then the key's data payload, message ID, and metadata will be written to the newly created ledger."}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"If the key doesn't match the latest then the message will be skipped and left alone."}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:["If any given message has an empty payload, it will be skipped and considered deleted (akin to the concept of ",(0,s.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Tombstone_(data_store)",children:"tombstones"})," in key-value databases)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"At the end of this second iteration through the topic, the newly created BookKeeper ledger is closed and two things are written to the topic's metadata:"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"The ID of the BookKeeper ledger"}),"\n",(0,s.jsxs)(o.li,{children:["The message ID of the last compacted message (this is known as the ",(0,s.jsx)(o.strong,{children:"compaction horizon"})," of the topic)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"Once this metadata is written compaction is complete."}),"\n",(0,s.jsxs)(o.ol,{start:"4",children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:["After the initial compaction operation, the Pulsar ",(0,s.jsx)(o.a,{href:"/docs/4.0.x/concepts-architecture-overview#brokers",children:"broker"})," that owns the topic is notified whenever any future changes are made to the compaction horizon and compacted backlog. When such changes occur:"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["Clients (consumers and readers) that have read compacted enabled will attempt to read messages from a topic and either:","\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"Read from the topic like normal (if the message ID is greater than or equal to the compaction horizon) or"}),"\n",(0,s.jsx)(o.li,{children:"Read beginning at the compaction horizon (if the message ID is lower than the compaction horizon)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.h2,{id:"compaction-configuration",children:"Compaction Configuration"}),"\n",(0,s.jsx)(o.p,{children:"Topic compaction behavior can be configured through various broker settings:"}),"\n",(0,s.jsx)(o.h3,{id:"key-configuration-parameters",children:"Key Configuration Parameters"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.strong,{children:(0,s.jsx)(o.code,{children:"compactionRetainNullKey"})}),": Controls whether null keys are retained during compaction. When set to ",(0,s.jsx)(o.code,{children:"true"}),", messages with null keys are preserved in the compacted ledger. When ",(0,s.jsx)(o.code,{children:"false"})," (default), messages with null keys are treated as non-key messages and may be removed during compaction."]}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.strong,{children:(0,s.jsx)(o.code,{children:"brokerServiceCompactionThreshold"})}),": The threshold size (in bytes) that triggers automatic compaction for a topic's backlog. When the topic's backlog exceeds this size, compaction will be triggered automatically."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.h3,{id:"null-key-handling",children:"Null Key Handling"}),"\n",(0,s.jsxs)(o.p,{children:["The ",(0,s.jsx)(o.code,{children:"compactionRetainNullKey"})," parameter is particularly important for topics that contain messages without keys. This configuration determines how the compaction process handles such messages:"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsxs)(o.strong,{children:["Enabled (",(0,s.jsx)(o.code,{children:"true"}),")"]}),": Messages with null keys are preserved during compaction, ensuring that unkeyed messages remain accessible in the compacted view."]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsxs)(o.strong,{children:["Disabled (",(0,s.jsx)(o.code,{children:"false"}),")"]}),": Messages with null keys may be removed during compaction, as they cannot be properly deduplicated without a key."]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"This setting is useful for topics that mix keyed and unkeyed messages, allowing administrators to control whether unkeyed messages should be retained in the compacted topic."}),"\n",(0,s.jsx)(o.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"Compaction frequency"}),": Balance between storage savings and CPU/I/O overhead"]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"Topic size"}),": Larger topics take longer to compact but may benefit more from compaction"]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"Key distribution"}),": Topics with many unique keys benefit less from compaction"]}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,o,t)=>{t.d(o,{R:()=>c,x:()=>a});var n=t(96540);const s={},i=n.createContext(s);function c(e){const o=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(i.Provider,{value:o},e.children)}}}]);