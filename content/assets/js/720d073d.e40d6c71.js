"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[48566],{62598:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"transactions","title":"Transactions","description":"Transactional semantics enable event streaming applications to consume, process, and produce messages in one atomic operation. In Pulsar, a producer or consumer can work with messages across multiple topics and partitions and ensure those messages are processed as a single unit.","source":"@site/docs/concepts-transactions.md","sourceDirName":".","slug":"/transactions","permalink":"/docs/next/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/docs/concepts-transactions.md","tags":[],"version":"current","frontMatter":{"id":"transactions","title":"Transactions","sidebar_label":"Overview"}}');var i=t(74848),s=t(28453);const r={id:"transactions",title:"Transactions",sidebar_label:"Overview"},o=void 0,c={},d=[{value:"Transaction coordinator and transaction log",id:"transaction-coordinator-and-transaction-log",level:2},{value:"Transaction ID",id:"transaction-id",level:2},{value:"Transaction buffer",id:"transaction-buffer",level:2},{value:"Pending acknowledge state",id:"pending-acknowledge-state",level:2},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"Transaction Log Batching",id:"transaction-log-batching",level:3},{value:"Pending Acknowledgment Batching",id:"pending-acknowledgment-batching",level:3},{value:"Segmented Transaction Buffer Snapshots",id:"segmented-transaction-buffer-snapshots",level:3},{value:"Transaction Buffer Performance Tuning",id:"transaction-buffer-performance-tuning",level:3},{value:"Transaction Isolation and Consistency",id:"transaction-isolation-and-consistency",level:2},{value:"Read Committed Isolation",id:"read-committed-isolation",level:3},{value:"Cross-Partition Consistency",id:"cross-partition-consistency",level:3},{value:"Transaction Timeouts and Recovery",id:"transaction-timeouts-and-recovery",level:2},{value:"Timeout Management",id:"timeout-management",level:3},{value:"Coordinator Recovery",id:"coordinator-recovery",level:3},{value:"Configuration and Best Practices",id:"configuration-and-best-practices",level:2},{value:"Key Configuration Parameters",id:"key-configuration-parameters",level:3},{value:"Core Transaction Settings",id:"core-transaction-settings",level:4},{value:"Batched Write Settings",id:"batched-write-settings",level:4},{value:"Buffer and Snapshot Settings",id:"buffer-and-snapshot-settings",level:4},{value:"Performance and Limits",id:"performance-and-limits",level:4},{value:"Performance Considerations",id:"performance-considerations",level:3}];function l(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"Transactional semantics enable event streaming applications to consume, process, and produce messages in one atomic operation. In Pulsar, a producer or consumer can work with messages across multiple topics and partitions and ensure those messages are processed as a single unit."}),"\n",(0,i.jsx)(e.p,{children:"The following concepts help you understand Pulsar transactions."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-coordinator-and-transaction-log",children:"Transaction coordinator and transaction log"}),"\n",(0,i.jsx)(e.p,{children:"The transaction coordinator maintains the topics and subscriptions that interact in a transaction. When a transaction is committed, the transaction coordinator interacts with the topic owner broker to complete the transaction."}),"\n",(0,i.jsx)(e.p,{children:"The transaction coordinator maintains the entire life cycle of transactions and prevents a transaction from incorrect status."}),"\n",(0,i.jsx)(e.p,{children:"The transaction coordinator handles transaction timeout and ensures that the transaction is aborted after a transaction timeout."}),"\n",(0,i.jsx)(e.p,{children:"All the transaction metadata is persisted in the transaction log. The transaction log is backed by a Pulsar topic. After the transaction coordinator crashes, it can restore the transaction metadata from the transaction log."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-id",children:"Transaction ID"}),"\n",(0,i.jsx)(e.p,{children:"The transaction ID (TxnID) identifies a unique transaction in Pulsar. The transaction ID is 128-bit. The highest 16 bits are reserved for the ID of the transaction coordinator, and the remaining bits are used for monotonically increasing numbers in each transaction coordinator. It is easy to locate the transaction crash with the TxnID."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-buffer",children:"Transaction buffer"}),"\n",(0,i.jsx)(e.p,{children:"Messages produced within a transaction are stored in the transaction buffer. The messages in transaction buffer are not materialized (visible) to consumers until the transactions are committed. The messages in the transaction buffer are discarded when the transactions are aborted."}),"\n",(0,i.jsx)(e.h2,{id:"pending-acknowledge-state",children:"Pending acknowledge state"}),"\n",(0,i.jsx)(e.p,{children:"Message acknowledges within a transaction are maintained by the pending acknowledge state before the transaction completes. If a message is in the pending acknowledge state, the message cannot be acknowledged by other transactions until the message is removed from the pending acknowledge state."}),"\n",(0,i.jsx)(e.p,{children:"The pending acknowledge state is persisted in the pending acknowledge log. The pending acknowledge log is backed by a Pulsar topic. A new broker can restore the state from the pending acknowledge log to ensure the acknowledgment is not lost."}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,i.jsx)(e.h3,{id:"transaction-log-batching",children:"Transaction Log Batching"}),"\n",(0,i.jsx)(e.p,{children:"Pulsar supports batched writing to transaction logs to improve performance and reduce the overhead of maintaining transaction state. When enabled, multiple transaction log entries are batched together before writing to storage, reducing I/O operations and improving throughput."}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key configuration parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteEnabled"}),": Enable batched writing for transaction logs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxRecords"}),": Maximum number of records in a batch"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxSize"}),": Maximum size of a batch in bytes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxDelayInMillis"}),": Maximum delay before flushing a batch"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"pending-acknowledgment-batching",children:"Pending Acknowledgment Batching"}),"\n",(0,i.jsx)(e.p,{children:"To improve performance when handling large numbers of pending acknowledgments, Pulsar supports batching of pending acknowledgment operations. This reduces the overhead of maintaining pending ack state for high-throughput transactional workloads."}),"\n",(0,i.jsx)(e.h3,{id:"segmented-transaction-buffer-snapshots",children:"Segmented Transaction Buffer Snapshots"}),"\n",(0,i.jsx)(e.p,{children:"For handling large numbers of aborted transactions efficiently, Pulsar implements segmented snapshot functionality. This feature helps manage transaction buffer snapshots more effectively when dealing with scenarios involving many aborted transactions."}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Improved memory management for transaction buffers"}),"\n",(0,i.jsx)(e.li,{children:"Better handling of abort scenarios with large transaction volumes"}),"\n",(0,i.jsx)(e.li,{children:"Reduced snapshot overhead for transaction recovery"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"transaction-buffer-performance-tuning",children:"Transaction Buffer Performance Tuning"}),"\n",(0,i.jsx)(e.p,{children:"Recent improvements include enhanced transaction buffer configurations for performance tuning:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Buffer size optimization"}),": Configurable buffer sizes for different workload patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Batch processing"}),": Improved batching within transaction buffers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory management"}),": Better memory allocation strategies for transaction data"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"transaction-isolation-and-consistency",children:"Transaction Isolation and Consistency"}),"\n",(0,i.jsx)(e.h3,{id:"read-committed-isolation",children:"Read Committed Isolation"}),"\n",(0,i.jsxs)(e.p,{children:["Pulsar transactions provide ",(0,i.jsx)(e.strong,{children:"read committed"})," isolation level, ensuring that:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Consumers only see messages from committed transactions"}),"\n",(0,i.jsx)(e.li,{children:"Uncommitted messages remain invisible until transaction commit"}),"\n",(0,i.jsx)(e.li,{children:"Aborted transactions have their messages discarded automatically"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"cross-partition-consistency",children:"Cross-Partition Consistency"}),"\n",(0,i.jsx)(e.p,{children:"Transactions in Pulsar can span multiple topics and partitions while maintaining consistency:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Atomic commits"}),": All operations within a transaction succeed or fail together"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coordinator-managed state"}),": Transaction coordinator ensures consistent state across partitions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Failure recovery"}),": System can recover to consistent state after coordinator failures"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"transaction-timeouts-and-recovery",children:"Transaction Timeouts and Recovery"}),"\n",(0,i.jsx)(e.h3,{id:"timeout-management",children:"Timeout Management"}),"\n",(0,i.jsx)(e.p,{children:"The transaction coordinator handles transaction timeouts to prevent indefinitely hanging transactions:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Configurable timeouts"}),": Set appropriate timeout values for different use cases"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Automatic abort"}),": Transactions are automatically aborted when they exceed timeout"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Resource cleanup"}),": Timed-out transactions have their resources cleaned up automatically"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"coordinator-recovery",children:"Coordinator Recovery"}),"\n",(0,i.jsx)(e.p,{children:"When a transaction coordinator fails, recovery mechanisms ensure transaction consistency:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State restoration"}),": Transaction state is restored from transaction logs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pending transaction handling"}),": In-progress transactions are properly handled during recovery"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Metadata consistency"}),": Transaction metadata remains consistent across coordinator restarts"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"configuration-and-best-practices",children:"Configuration and Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"key-configuration-parameters",children:"Key Configuration Parameters"}),"\n",(0,i.jsx)(e.h4,{id:"core-transaction-settings",children:"Core Transaction Settings"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionCoordinatorEnabled"}),": Enable transaction coordinator in broker (default: ",(0,i.jsx)(e.code,{children:"false"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionMetadataStoreProviderClassName"}),": Transaction metadata store provider class (default: ",(0,i.jsx)(e.code,{children:"org.apache.pulsar.transaction.coordinator.impl.MLTransactionMetadataStoreProvider"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferProviderClassName"}),": Transaction buffer provider class (default: ",(0,i.jsx)(e.code,{children:"org.apache.pulsar.broker.transaction.buffer.impl.TopicTransactionBufferProvider"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionPendingAckStoreProviderClassName"}),": Transaction pending ack store provider class (default: ",(0,i.jsx)(e.code,{children:"org.apache.pulsar.broker.transaction.pendingack.impl.MLPendingAckStoreProvider"}),")"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"batched-write-settings",children:"Batched Write Settings"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteEnabled"}),": Enable batched transaction log writes for better efficiency (default: ",(0,i.jsx)(e.code,{children:"false"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxRecords"}),": Maximum log records count in a batch (default: ",(0,i.jsx)(e.code,{children:"512"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxSize"}),": Maximum bytes size in a batch (default: ",(0,i.jsx)(e.code,{children:"4194304"})," - 4 MB)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionLogBatchedWriteMaxDelayInMillis"}),": Maximum wait time for first record in batch (default: ",(0,i.jsx)(e.code,{children:"1"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionPendingAckBatchedWriteEnabled"}),": Enable batched writes for pending ack store (default: ",(0,i.jsx)(e.code,{children:"false"}),")"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"buffer-and-snapshot-settings",children:"Buffer and Snapshot Settings"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferSegmentedSnapshotEnabled"}),": Enable segmented buffer snapshots for handling large numbers of aborted transactions (default: ",(0,i.jsx)(e.code,{children:"false"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferSnapshotMaxTransactionCount"}),": Take snapshot after this many transaction operations (default: ",(0,i.jsx)(e.code,{children:"1000"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferSnapshotMinTimeInMillis"}),": Interval for taking snapshots in milliseconds (default: ",(0,i.jsx)(e.code,{children:"5000"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferSnapshotSegmentSize"}),": Size of snapshot segment in bytes (default: ",(0,i.jsx)(e.code,{children:"262144"})," - 256 KB)"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"performance-and-limits",children:"Performance and Limits"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"maxActiveTransactionsPerCoordinator"}),": Maximum active transactions per coordinator (default: ",(0,i.jsx)(e.code,{children:"0"})," - no limit)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"numTransactionReplayThreadPoolSize"}),": Thread pool size for transaction replay (default: number of CPU cores)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferClientMaxConcurrentRequests"}),": Maximum concurrent requests for buffer client (default: ",(0,i.jsx)(e.code,{children:"1000"}),")"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"transactionBufferClientOperationTimeoutInMills"}),": Buffer client operation timeout in milliseconds (default: ",(0,i.jsx)(e.code,{children:"3000"}),")"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Batch size tuning"}),": Optimize batch sizes for your workload characteristics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coordinator placement"}),": Distribute transaction coordinators appropriately"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Resource allocation"}),": Ensure adequate resources for transaction processing"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitoring"}),": Monitor transaction metrics for performance optimization"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["For detailed configuration and usage examples, see ",(0,i.jsx)(e.a,{href:"/docs/next/txn-what",children:"Pulsar transactions"}),"."]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var a=t(96540);const i={},s=a.createContext(i);function r(n){const e=a.useContext(s);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);