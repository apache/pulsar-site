"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[26996],{70880:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"concepts-tiered-storage","title":"Tiered Storage","description":"Pulsar\'s segment-oriented architecture allows for topic backlogs to grow very large, effectively without limit. However, this can become expensive over time.","source":"@site/versioned_docs/version-4.0.x/concepts-tiered-storage.md","sourceDirName":".","slug":"/concepts-tiered-storage","permalink":"/docs/4.0.x/concepts-tiered-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/pulsar-site/edit/main/versioned_docs/version-4.0.x/concepts-tiered-storage.md","tags":[],"version":"4.0.x","frontMatter":{"id":"concepts-tiered-storage","title":"Tiered Storage","sidebar_label":"Tiered Storage"}}');var r=n(74848),o=n(28453);const t={id:"concepts-tiered-storage",title:"Tiered Storage",sidebar_label:"Tiered Storage"},a=void 0,l={},d=[{value:"How Tiered Storage Works",id:"how-tiered-storage-works",level:2},{value:"Offloading Process",id:"offloading-process",level:3},{value:"Transparent Access",id:"transparent-access",level:3},{value:"Supported Storage Backends",id:"supported-storage-backends",level:2},{value:"Cloud Storage Providers",id:"cloud-storage-providers",level:3},{value:"On-Premises Solutions",id:"on-premises-solutions",level:3},{value:"Storage Classes and Cost Optimization",id:"storage-classes-and-cost-optimization",level:3},{value:"Configuration and Policies",id:"configuration-and-policies",level:2},{value:"Offloading Triggers",id:"offloading-triggers",level:3},{value:"Key Configuration Parameters",id:"key-configuration-parameters",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Read Performance",id:"read-performance",level:3},{value:"Write Performance",id:"write-performance",level:3},{value:"Cost Benefits",id:"cost-benefits",level:3},{value:"Use Cases and Benefits",id:"use-cases-and-benefits",level:2},{value:"Long-term Data Retention",id:"long-term-data-retention",level:3},{value:"Cost Optimization",id:"cost-optimization",level:3},{value:"Management and Operations",id:"management-and-operations",level:2},{value:"Monitoring",id:"monitoring",level:3},{value:"Automation",id:"automation",level:3}];function c(e){const s={a:"a",blockquote:"blockquote",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"Pulsar's segment-oriented architecture allows for topic backlogs to grow very large, effectively without limit. However, this can become expensive over time."}),"\n",(0,r.jsx)(s.p,{children:"One way to alleviate this cost is to use Tiered Storage. With tiered storage, older messages in the backlog can be moved from BookKeeper to a cheaper storage mechanism, while still allowing clients to access the backlog as if nothing had changed."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"Tiered Storage",src:n(70976).A+"",width:"1110",height:"697"})}),"\n",(0,r.jsx)(s.h2,{id:"how-tiered-storage-works",children:"How Tiered Storage Works"}),"\n",(0,r.jsx)(s.p,{children:"Tiered storage leverages Pulsar's segment-based architecture where data is stored in immutable segments (ledgers) in BookKeeper. When segments are sealed and become read-only, they can be safely offloaded to external storage systems."}),"\n",(0,r.jsx)(s.h3,{id:"offloading-process",children:"Offloading Process"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Segment Sealing"}),": When a BookKeeper ledger is closed (due to size limits, time limits, or manual triggers), it becomes immutable."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Eligibility Check"}),": The broker determines which segments are eligible for offloading based on configured policies."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Data Transfer"}),": Eligible segments are copied to the configured long-term storage backend."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Metadata Update"}),": BookKeeper metadata is updated to reference the external storage location."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Local Deletion"}),": After a configurable delay (default: 4 hours), the original data is deleted from BookKeeper."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"transparent-access",children:"Transparent Access"}),"\n",(0,r.jsx)(s.p,{children:"Consumers can access offloaded data transparently. When a consumer requests data that has been offloaded:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The broker checks BookKeeper metadata to determine the storage location"}),"\n",(0,r.jsx)(s.li,{children:"If data is in external storage, the broker retrieves it seamlessly"}),"\n",(0,r.jsx)(s.li,{children:"The consumer receives the data as if it were still in BookKeeper"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"supported-storage-backends",children:"Supported Storage Backends"}),"\n",(0,r.jsx)(s.p,{children:"Pulsar supports multiple storage backends for tiered storage:"}),"\n",(0,r.jsx)(s.h3,{id:"cloud-storage-providers",children:"Cloud Storage Providers"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Amazon S3"}),": Industry-standard object storage with multiple storage classes"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Google Cloud Storage (GCS)"}),": Google's object storage with lifecycle management"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Microsoft Azure Blob Storage"}),": Azure's object storage solution"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Alibaba Cloud OSS"}),": Alibaba's object storage service"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"on-premises-solutions",children:"On-Premises Solutions"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Filesystem"}),": Local or network-attached storage for on-premises deployments"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"S3-Compatible Storage"}),": MinIO, Ceph, and other S3-compatible solutions"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"storage-classes-and-cost-optimization",children:"Storage Classes and Cost Optimization"}),"\n",(0,r.jsx)(s.p,{children:"Different storage backends offer various storage classes:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Hot storage"}),": Immediate access, higher cost (S3 Standard, GCS Standard)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Cool storage"}),": Infrequent access, lower cost (S3 IA, GCS Nearline)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Cold storage"}),": Archive storage, lowest cost (S3 Glacier, GCS Coldline)"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"configuration-and-policies",children:"Configuration and Policies"}),"\n",(0,r.jsx)(s.h3,{id:"offloading-triggers",children:"Offloading Triggers"}),"\n",(0,r.jsx)(s.p,{children:"Tiered storage can be triggered by:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Size-based policies"}),": Offload when topic backlog exceeds a certain size"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Time-based policies"}),": Offload data older than a specified age"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Manual triggers"}),": Administrative commands via REST API or CLI"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Namespace-level policies"}),": Automatic offloading based on namespace configuration"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"key-configuration-parameters",children:"Key Configuration Parameters"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Offload threshold"}),": Minimum backlog size before offloading begins"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Offload deletion lag"}),": Delay before deleting data from BookKeeper after offloading"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Max block size"}),": Maximum size of data blocks uploaded to external storage"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Read buffer size"}),": Buffer size for reading offloaded data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Offload driver"}),": Backend storage driver configuration"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(s.h3,{id:"read-performance",children:"Read Performance"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"First access"}),": Reading offloaded data is slower than BookKeeper due to network latency"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Caching"}),": Some implementations cache frequently accessed offloaded data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Prefetching"}),": Brokers may prefetch data based on access patterns"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"write-performance",children:"Write Performance"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Asynchronous offloading"}),": Offloading occurs in the background without affecting write performance"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Parallel transfers"}),": Multiple segments can be offloaded concurrently"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Bandwidth management"}),": Configurable limits to prevent offloading from overwhelming network resources"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"cost-benefits",children:"Cost Benefits"}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["Data written to BookKeeper is replicated to 3 physical machines by default. However, once a segment is sealed in BookKeeper it becomes immutable and can be copied to long term storage. Long term storage can achieve cost savings by using mechanisms such as ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction",children:"Reed-Solomon error correction"})," to require fewer physical copies of data."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Cost savings come from:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Reduced replication"}),": External storage typically requires fewer replicas"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Storage class optimization"}),": Use cheaper storage classes for older data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Operational efficiency"}),": Reduced BookKeeper cluster storage requirements"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"use-cases-and-benefits",children:"Use Cases and Benefits"}),"\n",(0,r.jsx)(s.h3,{id:"long-term-data-retention",children:"Long-term Data Retention"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Compliance requirements"}),": Meet regulatory requirements for data retention"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Historical analysis"}),": Maintain access to historical data for analytics"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Audit trails"}),": Preserve message history for compliance and auditing"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"cost-optimization",children:"Cost Optimization"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Storage cost reduction"}),": Move cold data to cheaper storage tiers"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Operational efficiency"}),": Reduce BookKeeper storage requirements"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Elastic scaling"}),": Handle varying data volumes without over-provisioning"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"management-and-operations",children:"Management and Operations"}),"\n",(0,r.jsx)(s.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Offloading metrics"}),": Track offloading progress and performance"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Storage usage"}),": Monitor storage consumption across tiers"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Access patterns"}),": Analyze data access patterns for optimization"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"automation",children:"Automation"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Policy-based management"}),": Automated offloading based on predefined policies"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Lifecycle management"}),": Integration with cloud provider lifecycle policies"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Alerting"}),": Notifications for offloading failures or threshold breaches"]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["For detailed setup instructions and configuration examples, see the ",(0,r.jsx)(s.a,{href:"/docs/4.0.x/cookbooks-tiered-storage",children:"Tiered storage cookbook"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},70976:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/pulsar-tiered-storage-72d8b53762992cfeaa58ae3b48dd2522.png"},28453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>a});var i=n(96540);const r={},o=i.createContext(r);function t(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);